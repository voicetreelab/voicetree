<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>xterm.js Test Harness</title>

  <!-- Include xterm.js from CDN for simplicity -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>

  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: monospace;
      background: #1e1e1e;
    }

    #terminal-container {
      width: 100%;
      height: 500px;
      background: #000;
      padding: 10px;
      box-sizing: border-box;
    }

    .terminal-wrapper {
      height: 100%;
      position: relative;
    }

    .status {
      color: #0f0;
      margin-bottom: 10px;
    }

    .error {
      color: #f00;
    }
  </style>
</head>
<body>
  <div class="status" id="status">Initializing terminal...</div>
  <div id="terminal-container">
    <div class="terminal-wrapper"></div>
  </div>

  <script type="module">
    // Mock Electron API implementation
    class MockElectronAPI {
      constructor() {
        this.terminals = new Map();
        this.dataCallbacks = [];
        this.exitCallbacks = [];
      }

      terminal = {
        spawn: async () => {
          const terminalId = `mock-term-${Date.now()}`;
          const terminal = {
            id: terminalId,
            buffer: [],
            exitCode: null,
            active: true,
          };

          this.terminals.set(terminalId, terminal);

          // Simulate initial prompt
          setTimeout(() => {
            this.sendData(terminalId, 'mock@terminal:~$ ');
          }, 10);

          return { success: true, terminalId };
        },

        write: async (terminalId, data) => {
          const terminal = this.terminals.get(terminalId);
          if (!terminal || !terminal.active) {
            return { success: false, error: 'Terminal not found or inactive' };
          }

          terminal.buffer.push(data);

          // Echo the input back
          this.sendData(terminalId, data);

          // Process commands if we receive a newline
          if (data.includes('\n') || data.includes('\r')) {
            const command = terminal.buffer.join('').trim();
            terminal.buffer = [];

            setTimeout(() => {
              this.processCommand(terminalId, command);
            }, 10);
          }

          return { success: true };
        },

        resize: async (terminalId, cols, rows) => {
          const terminal = this.terminals.get(terminalId);
          if (!terminal) {
            return { success: false, error: 'Terminal not found' };
          }

          console.log(`Resizing terminal ${terminalId} to ${cols}x${rows}`);
          return { success: true };
        },

        kill: async (terminalId) => {
          const terminal = this.terminals.get(terminalId);
          if (!terminal) {
            return { success: false, error: 'Terminal not found' };
          }

          terminal.active = false;
          terminal.exitCode = 0;

          this.exitCallbacks.forEach(cb => cb(terminalId, 0));

          this.terminals.delete(terminalId);
          return { success: true };
        },

        onData: (callback) => {
          this.dataCallbacks.push(callback);
        },

        onExit: (callback) => {
          this.exitCallbacks.push(callback);
        }
      };

      sendData(terminalId, data) {
        this.dataCallbacks.forEach(cb => cb(terminalId, data));
      }

      processCommand(terminalId, command) {
        const cleanCommand = command.replace(/\r?\n/g, '').trim();
        let response = '';

        if (cleanCommand === 'echo "Hello Terminal"') {
          response = 'Hello Terminal\n';
        } else if (cleanCommand === 'pwd') {
          response = '/home/mock/terminal\n';
        } else if (cleanCommand === 'ls') {
          response = 'file1.txt  file2.txt  directory/\n';
        } else if (cleanCommand === 'echo $USER') {
          response = 'mockuser\n';
        } else if (cleanCommand === 'exit') {
          this.terminal.kill(terminalId);
          return;
        } else if (cleanCommand.startsWith('echo "')) {
          const match = cleanCommand.match(/echo "(.*)"/);
          if (match) {
            response = `${match[1]}\n`;
          }
        } else if (cleanCommand.startsWith('echo ')) {
          const text = cleanCommand.substring(5);
          response = `${text}\n`;
        } else if (cleanCommand === '') {
          // Empty command, just show prompt
          response = '';
        } else {
          response = `mock: command not found: ${cleanCommand}\n`;
        }

        if (response) {
          this.sendData(terminalId, response);
        }

        this.sendData(terminalId, 'mock@terminal:~$ ');
      }
    }

    // Setup mock API
    window.electronAPI = new MockElectronAPI();

    // Initialize xterm.js
    const term = new Terminal({
      cursorBlink: true,
      fontSize: 14,
      fontFamily: 'Menlo, Monaco, "Courier New", monospace',
      theme: {
        background: '#1e1e1e',
        foreground: '#cccccc',
      },
      cols: 80,
      rows: 24,
    });

    // Store terminal instance globally for test access
    window.terminalInstance = term;

    // Open terminal in container
    const container = document.querySelector('.terminal-wrapper');
    term.open(container);

    // Initialize connection
    async function initTerminal() {
      const statusEl = document.getElementById('status');

      try {
        const result = await window.electronAPI.terminal.spawn();

        if (result.success && result.terminalId) {
          statusEl.textContent = `Terminal connected: ${result.terminalId}`;
          window.currentTerminalId = result.terminalId;

          // Set up data listener
          window.electronAPI.terminal.onData((id, data) => {
            if (id === result.terminalId) {
              term.write(data);
            }
          });

          // Set up exit listener
          window.electronAPI.terminal.onExit((id, code) => {
            if (id === result.terminalId) {
              term.writeln(`\r\nProcess exited with code ${code}`);
              statusEl.textContent = 'Terminal disconnected';
              window.currentTerminalId = null;
            }
          });

          // Handle terminal input
          term.onData(data => {
            if (window.currentTerminalId) {
              window.electronAPI.terminal.write(window.currentTerminalId, data).catch(err => {
                console.error('Write error:', err);
              });
            }
          });
        } else {
          statusEl.textContent = 'Failed to spawn terminal';
          statusEl.className = 'error';
        }
      } catch (error) {
        statusEl.textContent = `Error: ${error.message}`;
        statusEl.className = 'error';
      }
    }

    // Initialize terminal after a short delay
    setTimeout(initTerminal, 100);

    // Focus terminal
    term.focus();
  </script>
</body>
</html>